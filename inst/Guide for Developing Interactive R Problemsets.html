<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Tutorial for Developing Interactive R Problem Sets with RTutor</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Tutorial for Developing Interactive R Problem Sets with RTutor</h1>

<p><strong>Date: 2013-08-11</strong></p>

<p><strong>Author: Sebastian Kranz</strong></p>

<p>RTutor is an R package that allows to develop interactive R exercises. The interactive exercises, can directly test a student&#39;s solution and provide hints if not everything is correct. A problems et is just a collection of interactive exercises. This document gives you an overview how to generate an interactive problem set. I assume that you are using RStudio.</p>

<h2>A step by step guide</h2>

<h3>1. Install the newest version of RTutor</h3>

<p>You first need to install some other packages. Simply run in R</p>

<pre><code class="r">install.packages(&quot;devtools&quot;, &quot;whisker&quot;, &quot;stringr&quot;)

</code></pre>

<p>To install the newest version of restorepoint and RTutor from Github run then</p>

<pre><code class="r">library(devtools)
install_github(repo = &quot;restorepoint&quot;, username = &quot;skranz&quot;)
install_github(repo = &quot;RTutor&quot;, username = &quot;skranz&quot;)
library(restorepoint)
library(RTutor)
</code></pre>

<h3>2. Create template files for developing a new problem set</h3>

<p>We first need to generate a folder in which some example files will be generated that help us to build a new problem set. First decide on a name for the problemset, e.g. &ldquo;my ps&rdquo; and generate a parent folder in which you want to save your problemsets, e.g. &ldquo;C:/problemsets&rdquo;. (Henceforth I will always assume that you named your problem set &ldquo;my ps&rdquo;. Just replace &ldquo;my ps&rdquo; everywhere by your own name) Then run the following code:</p>

<pre><code class="r">develop.problem.set(name = &quot;my ps&quot;, parent.path = &quot;C:/libraries/RTutor/problemsets&quot;)
</code></pre>

<p>It generates a new folder below parent.path with the name of the problem set, here &ldquo;C:/problemsets/my ps&rdquo;.</p>

<p>The generated folder contains 2 files:</p>

<ul>
<li>my ps_struc.r</li>
<li>make_student_ps.r</li>
</ul>

<p>Note: If these files do already exist, the existing files are by default <strong>not</strong> overwritten. You have to delete them manually if you want to generate new template files.</p>

<p>The file &ldquo;my ps_struc.r&rdquo; will contain all the <strong>structure</strong> of your problem set that specifies for several exercises:</p>

<ul>
<li>a task description shown to the student</li>
<li>a solution for the exercise</li>
<li>several tests that will check a student&#39;s solution and provide hints</li>
</ul>

<p>Originally, there is an example structure with two simple exercies. We will explain later in detail, how you create a structure for your own problem set..</p>

<p>The file &ldquo;make_student_ps.r&rdquo; contains a few lines of code that will generate from your problem set structure an empty problem set for the student.</p>

<h3>3. Generate an empty problem set for students</h3>

<p>Open the file &ldquo;make_student_ps.r&rdquo; and run all its code. In your problem set folder, a new file, &ldquo;my ps.r&rdquo; should now have been generated. This is the file that will be given to students and that they shall try to solve.</p>

<h3>4. Feel like a student: Try to solve the problem set</h3>

<p>Open the generated file &ldquo;my ps.r&rdquo; in RStudio. The file has some commands in the beginning, which are used to initialize RTutor. You can ignore them for the moment. Then there is a description for two exercises that tell you where you can enter your own code. Try to solve the exercises (or just exercise 1). Try also to make some mistakes, to check how whether these mistakes are found out.</p>

<h3>5. Feel like a student: Check your solution</h3>

<p>When you have written some code:</p>

<ol>
<li>First <strong>save your file</strong> (Ctrl-s or press the &#39;disk symbol&#39;)</li>
<li>Then source your file (Ctrl-Shift-s or press the symbol &#39;Source&#39; on top of your code to the right).</li>
</ol>

<p>RTutor will now check the solutions to your exercise and either give you a message that something is wrong, some warning messages or says everything is fine. Try out yourself&hellip;  </p>

<p>Hint: In RStudio above the code window there is a check box &ldquo;Source on Save&rdquo;. I would recommend to check this box for &ldquo;my ps.r&rdquo;. Now you only have to press Ctrl-s to automatically save and check your problem set.</p>

<h3>6. Change the structure of your problem set</h3>

<p>You can now change the structure of your problem set. This is explained in detail in the next section. Once, you have changed the structure, you can test it again by repeating steps 4 and 5 (and perhaps step 3).</p>

<h2>Specifying the structure of a problem set</h2>

<p>If you open &ldquo;my ps_struc.r&rdquo;, you see an example structure of a problem set. Here is the header and structure for the first exercise:</p>

<pre><code class="r">#$ problem_set my ps


###############################################################
#$ exercise a)
###############################################################

#$ task #######################################################
# Compute 2*5 and store it in the variable x  


#$ solution ###################################################

x &lt;- 2*5

#$ tests ######################################################
check.var(&quot;x&quot;, exists=TRUE,length=TRUE, values=TRUE)

#$ hints ######################################################
add.hint(&quot;Hint 1&quot;,{cat(&#39;
# The following code stores 2+3 in a variable y
y = 2+3&quot;
&#39;)})

#$ end_exercise

</code></pre>

<p>Lines that start with #$ are special commands that are used by RTutor to parse different aspects of the problem sets. Other lines are all valid R commands. I explain the commands in detail:</p>

<h3>Specify name of a problem set</h3>

<p>The command</p>

<pre><code class="r"># $ problem_set my ps
</code></pre>

<p>simply sets the name of the problem set equal to the text after problem_set. Here the name is set to &ldquo;my ps&rdquo;. As in this example, the name of a problem set can contain spaces.</p>

<h3>Specify an exercise</h3>

<p>A problem set can have several exercises. Each exercises must have the following command lines in <strong>exactly the order shown below</strong>. After most command lines some R code can be entered.  </p>

<pre><code class="r">#$ exercise name_of_exercise

  # No code will be entered here 

#$ task

  # Code that will be part of the empty problem set given to the student

#$ solution

  # Code that would correctly solve the exercise

#$ tests

  # Tests that will be performed on the student&#39;s code

#$ hints

  # Code that specifies hints that can be shown to the
  # students in specified situations

#$ end_exercise
</code></pre>

<p>I will now explain the different commands</p>

<h4>#$ exercise</h4>

<p>This command is at the start of an exercise. After the word exercise, a name of the exercise is specified, e.g.</p>

<pre><code class="r"># $ exercise a)
</code></pre>

<p>generates an exercise with name &ldquo;a)&rdquo;. So far, we don&#39;t use any R code directly after the command.</p>

<h4>#$ task</h4>

<p>Below this command, you enter the text will be shown in the empty problem set given to the user. The text should make clear, what the student shall do and where she should enter her code.  Unless, you have a good reason, this text should be valid R code, i.e. everything that is used for explanations should be commented with #.</p>

<p>Example:</p>

<pre><code class="r">#$ task #######################################################

# Compute 2*5 and store it in the variable x  

</code></pre>

<h4>#$ solution</h4>

<p>Below this command, you enter R code that completely solves the exercise.
Example:</p>

<pre><code class="r">#$ solution ###################################################

x &lt;- 2*5
</code></pre>

<h4>#$ tests</h4>

<p>Below this command you specify different tests that will be performed on the student&#39;s solution to check whether some mistake can be found. If something wrong is encountered, the tests give feedback to the student.</p>

<p>The simple test in our example below, checks the following:</p>

<ul>
<li>Has the user generated a variable x</li>
<li>Has x the same length as in the given solution, i.e. 1</li>
<li>Has x the same value as in the given solution, i.e. x=10</li>
</ul>

<pre><code class="r">#$ tests ###################################################

check.var(&quot;x&quot;, exists=TRUE,length=TRUE, values=TRUE)

</code></pre>

<p>If one test fails, e.g. if x does not exist. The user will be shown a standard failure message and no more code will be checked. We consider a student&#39;s solution &ldquo;correct&rdquo; if no test fails, i.e. we are not able to falsify the correctness.</p>

<p>Good and well designed tests are the key component of a good interactive problem set. There already exist several functions, like check.var, that can be used to perform different sorts of tests. They are explained in some detail in the next section.
If more functions are needed, e.g. a function that scans the code of the user for a particular command, send me an email or file an issue on GitHub.</p>

<h4>#$ hints</h4>

<p>In the code below the #$ hints command, you can specify several hints that can be shown to the student.  You can call here the function add.hint that allows to add a hint to the exercise.</p>

<p>The example generates a hint, that will give the user the solution to a similar exercise and that should be sufficient to solve the current exercise, even without any R knowledge.</p>

<pre><code class="r">#$ hints ###################################################

add.hint(&quot;Hint 1&quot;,{cat(&#39;
# The following code stores 2+3 in a variable y
y = 2+3&quot;
&#39;)})
</code></pre>

<p>I have not yet well worked out when and how hints shall be shown. One could think of the user asking for a hint, by calling a function hint(). Alternatively, one could offer the student a hint if he fails to often. Any ideas are very welcome.</p>

<h4>#$ end exercise</h4>

<p>This command simply indicates that the specification of the exercise is done. Afterwards, you can specify the structure of a new exercise, if you like.</p>

<h2>Specifying Tests</h2>

<p>As said before, well specified tests that analyse the student&#39;s solution are crucial for a good problem set. Here I want to give an overview of some functions that can generate the test. A more detailed description of the test functions can be found in the R-help of the RTutor package. Consider the specification of exercise &ldquo;b)&rdquo; in the example file.</p>

<pre><code class="r">

############################################################### $ exercise
############################################################### b)

# $ task #######################################################

# Draw Simulate T outputs from a demand function q = beta0 + beta1 * p +
# eps


T = 1000  # Number of markets
beta0 = 100
beta1 = -1

# i) Draw T demand shocks eps from a normal distribution with mean 0 and
# variance 4

# ii) Generate a vector of endogenous prices

# iii) Compute realized demand q from demand function q=beta0+beta1*p+eps


# $ solution ###################################################
T = 1000  # Number of markets
beta0 = 100
beta1 = -1
# Draw demand shocks eps from a normal distribution with mean 0 and
# variance 4
eps = rnorm(T, 0, 2)
# One solution to generate endogenous prices
p = eps/2
# Compute realized demand q
q = beta0 + beta1 * p + eps
# $ tests ######################################################

# Check given variables
check.var(c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;T&quot;), exists = TRUE, length = TRUE, class = TRUE, 
    values = TRUE)

# Check construction of eps
check.var(c(&quot;eps&quot;), exists = TRUE, length = TRUE, class = TRUE)

test.normality(eps, alpha.failure = 0.001, alpha.warning = 0.05)
test.mean(eps, 0)
test.variance(eps, 4)

# Check p
check.var(c(&quot;p&quot;), exists = TRUE, length = TRUE, class = TRUE)

test.H0.rejected(cor.test(p, eps), check.warning = FALSE, alpha.failure = 0.05, 
    failure.message = &quot; I couldn&#39;t significantly reject the hypothesis that your prices are exogenous (H0: cor(p,eps)=0, p.value = {{p_value}}). Try harder to generate prices that are &#39;significantly&#39; endogenous.&quot;)

# Check q
check.var(c(&quot;q&quot;), exists = TRUE, length = TRUE, class = TRUE)

holds.true({
    q.shall = beta0 + beta1 * p + eps
    q == q.shall
}, failure.message = &quot;Sorry, you have not specified the correct demand equation q = ... (or perhaps you have changed q somewhere later in the code)&quot;)

# $ hints ######################################################

# $ end_exercise

</code></pre>

<p>Tests are performed in the following order:</p>

<ol>
<li><p>Test that existing variables beta0, beta1, T are not changed</p></li>
<li><p>Test that eps are created correctly from the specified normal distribution</p></li>
<li><p>Test that prices p are correct and indeed endogenous</p></li>
<li><p>Test that the output q is correct given the student&#39;s eps and p</p></li>
</ol>

<p>Let me explain the different used tests:</p>

<h3>check.var</h3>

<pre><code class="r">check.var(c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;T&quot;), exists = TRUE, length = TRUE, class = TRUE, 
    values = TRUE)
check.var(c(&quot;eps&quot;), exists = TRUE, length = TRUE, class = TRUE)
</code></pre>

<p>The command check.var compares the users variables with the corresponding variables in the specified solution. We can check different aspects, by setting that flag TRUE</p>

<ul>
<li>exists does the variable exist at all</li>
<li>length has the variable the same length as in the solution</li>
<li>class has the variable the same class as in the solution (e.g. numeric, character,data.frame,&hellip;)</li>
<li>values has the variable the same values as in the solution</li>
</ul>

<p>Since eps shall be a vector of random variables, it does not make sense to check whether the values are identical to the randomly selected values in the solution. So we only test for existence, correct length and class.</p>

<h3>test.normality, test.mean test.variance</h3>

<pre><code class="r">test.normality(eps, alpha.failure = 0.001, alpha.warning = 0.05)
test.mean(eps, 0)
test.variance(eps, 4)
</code></pre>

<p>These three tests are used to determine in a statistical fashion whether eps satisfies the null hypothesises:</p>

<ul>
<li>normally distributed</li>
<li>has mean 0</li>
<li>has a variance of 4</li>
</ul>

<p>The tests perform statistical tests on the given vector and return a failure if the null hypothesis can be rejected at a significance level below alpha.failure. If the p-value is above alpha.failure but above alpha.warning just a warning will be shown. If not provided manually, the default values are alpha.failure = 0.1% and alpha.warning = 5%. You can look in the help pages for RTutor to get more details on these functions.</p>

<h3>test.H0.rejected and test.H0</h3>

<p>For the prices p we first check existence, lengt and class with check.var. Then we implement a manual test whether p is indeed endogenous with the function test.H0.rejected.</p>

<pre><code class="r">check.var(c(&quot;p&quot;), exists = TRUE, length = TRUE, class = TRUE)

test.H0.rejected(cor.test(p, eps), check.warning = FALSE, alpha.failure = 0.05, 
    failure.message = &quot; I couldn&#39;t significantly reject the hypothesis that your prices are exogenous (H0: cor(p,eps)=0, p.value = {{p_value}}). Try harder to generate prices that are &#39;significantly&#39; endogenous.&quot;)

</code></pre>

<p>The first argument to test.H0.rejected is an expression that calls a statistical test, that returns a list that has an element p.value. Here we test the correlation between prices and eps by calling cor.test(p,eps). This expression will be evaluated with the student&#39;s solution. The student&#39;s solution passes our test , if we can <strong>reject</strong> the null hypothesis of this test,cor(p,eps)=0, at a level of alpha.failure = 0.05. (Recall from your econometrics classes that an explanatory variable p is endogenous if it is correlated with the error term eps.)</p>

<p>We have a similar function test.H0 which would be passed if H0 can <strong>not be rejected</strong>.</p>

<h4>failure.message</h4>

<p>If the test fails, we can specify a manual failure.message that will be shown to the user. Our failure message contains the following whiskers: {{p_value}}. This part of the message will be replaced by the actual p-value of the test. Another whisker you can use is  &ldquo;{{test_name}}&rdquo; that will be replaced by the name of the test.</p>

<h3>holds.true</h3>

<p>Finally, we check the simulated output q.</p>

<pre><code class="r">check.var(c(&quot;q&quot;), exists = TRUE, length = TRUE, class = TRUE)
holds.true({
    q.shall = beta0 + beta1 * p + eps
    q == q.shall
}, failure.message = &quot;Sorry, you have not specified the correct demand equation q = ...&quot;)
</code></pre>

<p>holds.true is a quite general testing function that checks whether a boolean condition (or all elements of a boolean vector) hold true given the student&#39;s solution. The first argument in {} is some code that will be evaluted given the student&#39;s solution. The last line of that code must be a boolean condition (or a vector of boolean condition). The test fails if one element of the boolean vector is false. Again, we specify a manual failure.message.</p>

</body>

</html>

