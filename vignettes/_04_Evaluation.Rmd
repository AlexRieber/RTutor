---
title: "4 Order of Solving and Evaluation Environments"
output:
  html_document:
    toc: yes
---
```{r setup, include="FALSE"}
knitr::opts_chunk$set(eval=FALSE, cache=FALSE)
```

# 4 Evaluation Order and Environments

This section gives a short overview about the order in which students have to solve problem sets and methods for customization. We also give some background information about the environments in which solutions are evaluated.

## Default Rule: Exercises Matter

The default evaluation order is that within an exercise chunks must be solved in the given order. In contrast, it is not neccessary to have solved all previous exercises to start a new exercise.

Recall that the start of a new exercise is determined in your solution file with a line like:

```s
## Exercise 1 -- My First Exercise`
```
## Environments in which chunks are tested

Testing a chunk takes place in an own environment that is not equal to the global workspace.

By default all chunks inside an exercise are evaluated in an environment in which all created variables of earlier chunks in the same exercise are available. Since by default you can only proceed if previous chunks in the exercise are solved correctly, this guarantees that in the testing environment you have the *correct* solutions of earlier chunks available.

## Environments in which hints are evaluated

Adaptive hints also evaluate expression in an environment. If `hint()` is called we essentially have the test environment and it also contains the variables created when the current chunk was evaluated during the last check. Note that `hint()` itself does not by default newly evaluate the student's code. This means one always should first check a modified solution before asking for a new hint.


## Using variables from earlier exercises (NOT RECOMMENDED)

By default variables that have been generated by the student in earlier *exercises* are not known in the current exercise.

It is possible to use variables from earlier exercises, but that is typically not recommended, because then one can only start with a new exercise if the previous has been solved. Often it is better make each exercise self-contained. An exception were it make sense is that you have a very simple initial exercise (that every student should pass) that just loads a data set and all later exercises use the data set from that initial exercise. 

Here is an example:
```
    ## Exercise 2 -- Proceed with the data analysis
    
    ```{r}`r ''`
    #< settings
    import.var = list("1"="dat")
    #>
    ```
    a) Add a column `ones` to dat that only contains 1. Show dat.
    ```{r}`r ''`
    dat$ones = 1
    dat
    ```
```
As you see, in order to use variables from earlier exercises, you must add at the beginning of an exercise a settings block that defines a variable `import.var`, like
```
    ```{r}`r ''`
    #< settings
    import.var = list("1"="dat")
    #>
    ```
```
The variable `import.var` is a list whose element names correspond to the short exercise names (part of the name before --) from which you want to import variables. The list elements are character vectors of the variable names you want to import from the corresponding exercise.


## Optional chunks

If you set the chunk option `optional=TRUE`, a chunk need not be solved in order to continue the exercise. Example:

```  
    ```{r "1_b", optional = TRUE}`r ''`
    # Code here
    
    ```
```  

Variables generated in an optional chunk will *not* be available in later chunks of the exercise. That is because we cannot be sure anyways whether these variables exist or not.

The environment in which an optional chunk is tested will contain all variables created in non-optional chunks earlier in the exercise.

## extra.code.file

The function `create.ps` has an argument `extra.code.file`. This can be set to a file name of an R file. This R file will be sourced when the problem set is generated and all created variables and functions will be available in ALL chunks when chunks are tested. This usually only makes sense for shiny based problem sets.

Note that you don't have to give the extra code R file to the students. The information will be included in the problem set rps file.

## preknit blocks

preknit blocks are declared outside of code chunks and start with `#< preknit` and end with `#>`.

Any rmd code inside a preknit block will be knitted at compile-time and shown as usual RMarkdown output in the shiny based version of the problem set. This is very similar to the output of an info block, except that it is not put into a collapsible.

Note that code that was evaluated in an earlier preknit block or earlier info block will be available at compile time at later info or preknit blocks, no matter which exercise the blocks are in. If you want just to do some preliminary computations for later info or preknit blocks without showing any output, add a chunk with the chunk option `include=FALSE` in a preknit block.
